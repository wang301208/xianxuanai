"""Observers that connect reasoning modules with the global workspace."""

from __future__ import annotations

import json
from dataclasses import dataclass
from typing import Dict, List, Optional

from .symbolic import SymbolicReasoner
from .commonsense import CommonsenseValidator
from .causal import KnowledgeGraphCausalReasoner
from .logic import LogicRule


@dataclass
class WorkspaceSignal:
    """Feedback generated by observers when monitoring agent thoughts."""

    source: str
    severity: str
    message: str
    evidence: List[str]


class WorkspaceObserver:
    """Protocol-style base class for observers."""

    name: str

    def evaluate(self, thought: str, context: Dict[str, object]) -> Optional[WorkspaceSignal]:
        raise NotImplementedError


class LogicConstraintObserver(WorkspaceObserver):
    name = "logic"

    def __init__(self, reasoner: SymbolicReasoner) -> None:
        self._reasoner = reasoner

    def evaluate(self, thought: str, context: Dict[str, object]) -> Optional[WorkspaceSignal]:
        payload = _safe_json(thought)
        if not payload:
            return None
        ability = str(payload.get("next_ability", ""))
        arguments = payload.get("ability_arguments", {})
        task = str(context.get("task_objective", ""))
        needs_logic = any(keyword in task.lower() for keyword in ["prove", "logic", "constraint", "consistent"])
        if ability == "symbolic_reason":
            goal = str(arguments.get("goal", ""))
            premises = arguments.get("premises", [])
            rules = _parse_rules(arguments.get("rules"))
            holds, proof = self._reasoner.prove(
                goal,
                premises=premises or [],
                rules=rules,
            )
            if not holds:
                return WorkspaceSignal(
                    source=self.name,
                    severity="error",
                    message=f"Unable to derive goal '{goal}' from provided premises.",
                    evidence=proof,
                )
            return WorkspaceSignal(
                source=self.name,
                severity="info",
                message=f"Logical proof for '{goal}' verified.",
                evidence=proof,
            )
        if needs_logic and ability != "symbolic_reason":
            return WorkspaceSignal(
                source=self.name,
                severity="warning",
                message="Task mentions logical verification but ability selection lacks symbolic reasoning step.",
                evidence=[task],
            )
        return None


class CausalObserver(WorkspaceObserver):
    name = "causal"

    def __init__(self, reasoner: KnowledgeGraphCausalReasoner) -> None:
        self._reasoner = reasoner

    def evaluate(self, thought: str, context: Dict[str, object]) -> Optional[WorkspaceSignal]:
        payload = _safe_json(thought)
        if not payload:
            return None
        ability = str(payload.get("next_ability", ""))
        arguments = payload.get("ability_arguments", {})
        task = str(context.get("task_objective", ""))
        mentions_causal = any(keyword in task.lower() for keyword in ["cause", "impact", "effect", "result"])
        if ability == "causal_reason":
            cause = str(arguments.get("cause", ""))
            effect = str(arguments.get("effect", ""))
            exists, path = self._reasoner.check_causality(cause, effect)
            if not exists:
                return WorkspaceSignal(
                    source=self.name,
                    severity="warning",
                    message=f"No causal path between {cause} and {effect} in current knowledge graph.",
                    evidence=[task],
                )
            predictions = self._reasoner.predict_effects(cause)
            evidence = [" -> ".join(path)] if path else []
            evidence.extend([f"{cause} => {target} (strength={strength:.2f})" for target, strength in predictions[:3]])
            return WorkspaceSignal(
                source=self.name,
                severity="info",
                message=f"Causal link between {cause} and {effect} verified.",
                evidence=evidence,
            )
        if mentions_causal and ability != "causal_reason":
            return WorkspaceSignal(
                source=self.name,
                severity="warning",
                message="Task references causal analysis but ability selection did not route to the causal reasoner.",
                evidence=[task],
            )
        return None


class CommonsenseObserver(WorkspaceObserver):
    name = "commonsense"

    def __init__(self, validator: CommonsenseValidator) -> None:
        self._validator = validator

    def evaluate(self, thought: str, context: Dict[str, object]) -> Optional[WorkspaceSignal]:
        payload = _safe_json(thought)
        if not payload:
            return None
        ability = str(payload.get("next_ability", ""))
        arguments = payload.get("ability_arguments", {})
        if ability != "commonsense_validate":
            return None
        subject = str(arguments.get("subject", ""))
        relation = str(arguments.get("relation", ""))
        obj = str(arguments.get("object", ""))
        judgement = self._validator.validate(
            subject,
            relation,
            obj,
            context=[str(context.get("task_objective", ""))],
        )
        evidence = judgement.evidence
        evidence_strings = [f"{s} {r} {o}" for s, r, o in evidence]
        return WorkspaceSignal(
            source=self.name,
            severity="info" if judgement.status == "consistent" else judgement.status,
            message=judgement.message,
            evidence=evidence_strings + judgement.suggestions,
        )


def _safe_json(text: str) -> Optional[Dict[str, object]]:
    try:
        data = json.loads(text)
        if isinstance(data, dict):
            return data
    except Exception:
        return None
    return None


def _parse_rules(data: object) -> List[LogicRule]:
    rules: List[LogicRule] = []
    if not isinstance(data, list):
        return rules
    for item in data:
        if not isinstance(item, dict):
            continue
        head = str(item.get("head", "")).strip()
        body = item.get("body", [])
        if not head or not isinstance(body, list):
            continue
        atoms = tuple(str(atom).strip() for atom in body if str(atom).strip())
        if not atoms:
            continue
        description = str(item.get("description", ""))
        rules.append(LogicRule(head=head, body=atoms, description=description))
    return rules
